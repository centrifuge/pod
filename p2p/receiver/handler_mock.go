// Code generated by mockery v2.13.0-beta.1. DO NOT EDIT.

package receiver

import (
	context "context"

	p2ppb "github.com/centrifuge/centrifuge-protobufs/gen/go/p2p"
	mock "github.com/stretchr/testify/mock"

	peer "github.com/libp2p/go-libp2p-core/peer"

	protocol "github.com/libp2p/go-libp2p-core/protocol"

	protocolpb "github.com/centrifuge/centrifuge-protobufs/gen/go/protocol"

	types "github.com/centrifuge/go-substrate-rpc-client/v4/types"
)

// HandlerMock is an autogenerated mock type for the Handler type
type HandlerMock struct {
	mock.Mock
}

// GetDocument provides a mock function with given fields: ctx, docReq, requester
func (_m *HandlerMock) GetDocument(ctx context.Context, docReq *p2ppb.GetDocumentRequest, requester *types.AccountID) (*p2ppb.GetDocumentResponse, error) {
	ret := _m.Called(ctx, docReq, requester)

	var r0 *p2ppb.GetDocumentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *p2ppb.GetDocumentRequest, *types.AccountID) *p2ppb.GetDocumentResponse); ok {
		r0 = rf(ctx, docReq, requester)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*p2ppb.GetDocumentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *p2ppb.GetDocumentRequest, *types.AccountID) error); ok {
		r1 = rf(ctx, docReq, requester)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleGetDocument provides a mock function with given fields: ctx, _a1, protoc, msg
func (_m *HandlerMock) HandleGetDocument(ctx context.Context, _a1 peer.ID, protoc protocol.ID, msg *p2ppb.Envelope) (*protocolpb.P2PEnvelope, error) {
	ret := _m.Called(ctx, _a1, protoc, msg)

	var r0 *protocolpb.P2PEnvelope
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) *protocolpb.P2PEnvelope); ok {
		r0 = rf(ctx, _a1, protoc, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocolpb.P2PEnvelope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) error); ok {
		r1 = rf(ctx, _a1, protoc, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleInterceptor provides a mock function with given fields: ctx, _a1, protoc, msg
func (_m *HandlerMock) HandleInterceptor(ctx context.Context, _a1 peer.ID, protoc protocol.ID, msg *protocolpb.P2PEnvelope) (*protocolpb.P2PEnvelope, error) {
	ret := _m.Called(ctx, _a1, protoc, msg)

	var r0 *protocolpb.P2PEnvelope
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID, *protocolpb.P2PEnvelope) *protocolpb.P2PEnvelope); ok {
		r0 = rf(ctx, _a1, protoc, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocolpb.P2PEnvelope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, protocol.ID, *protocolpb.P2PEnvelope) error); ok {
		r1 = rf(ctx, _a1, protoc, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleRequestDocumentSignature provides a mock function with given fields: ctx, _a1, protoc, msg
func (_m *HandlerMock) HandleRequestDocumentSignature(ctx context.Context, _a1 peer.ID, protoc protocol.ID, msg *p2ppb.Envelope) (*protocolpb.P2PEnvelope, error) {
	ret := _m.Called(ctx, _a1, protoc, msg)

	var r0 *protocolpb.P2PEnvelope
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) *protocolpb.P2PEnvelope); ok {
		r0 = rf(ctx, _a1, protoc, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocolpb.P2PEnvelope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) error); ok {
		r1 = rf(ctx, _a1, protoc, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HandleSendAnchoredDocument provides a mock function with given fields: ctx, _a1, protoc, msg
func (_m *HandlerMock) HandleSendAnchoredDocument(ctx context.Context, _a1 peer.ID, protoc protocol.ID, msg *p2ppb.Envelope) (*protocolpb.P2PEnvelope, error) {
	ret := _m.Called(ctx, _a1, protoc, msg)

	var r0 *protocolpb.P2PEnvelope
	if rf, ok := ret.Get(0).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) *protocolpb.P2PEnvelope); ok {
		r0 = rf(ctx, _a1, protoc, msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*protocolpb.P2PEnvelope)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, peer.ID, protocol.ID, *p2ppb.Envelope) error); ok {
		r1 = rf(ctx, _a1, protoc, msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RequestDocumentSignature provides a mock function with given fields: ctx, sigReq, collaborator
func (_m *HandlerMock) RequestDocumentSignature(ctx context.Context, sigReq *p2ppb.SignatureRequest, collaborator *types.AccountID) (*p2ppb.SignatureResponse, error) {
	ret := _m.Called(ctx, sigReq, collaborator)

	var r0 *p2ppb.SignatureResponse
	if rf, ok := ret.Get(0).(func(context.Context, *p2ppb.SignatureRequest, *types.AccountID) *p2ppb.SignatureResponse); ok {
		r0 = rf(ctx, sigReq, collaborator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*p2ppb.SignatureResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *p2ppb.SignatureRequest, *types.AccountID) error); ok {
		r1 = rf(ctx, sigReq, collaborator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendAnchoredDocument provides a mock function with given fields: ctx, docReq, collaborator
func (_m *HandlerMock) SendAnchoredDocument(ctx context.Context, docReq *p2ppb.AnchorDocumentRequest, collaborator *types.AccountID) (*p2ppb.AnchorDocumentResponse, error) {
	ret := _m.Called(ctx, docReq, collaborator)

	var r0 *p2ppb.AnchorDocumentResponse
	if rf, ok := ret.Get(0).(func(context.Context, *p2ppb.AnchorDocumentRequest, *types.AccountID) *p2ppb.AnchorDocumentResponse); ok {
		r0 = rf(ctx, docReq, collaborator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*p2ppb.AnchorDocumentResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *p2ppb.AnchorDocumentRequest, *types.AccountID) error); ok {
		r1 = rf(ctx, docReq, collaborator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type NewHandlerMockT interface {
	mock.TestingT
	Cleanup(func())
}

// NewHandlerMock creates a new instance of HandlerMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewHandlerMock(t NewHandlerMockT) *HandlerMock {
	mock := &HandlerMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
