// Code generated by mockery v2.13.0-beta.1. DO NOT EDIT.

package documents

import (
	context "context"

	coredocumentpb "github.com/centrifuge/centrifuge-protobufs/gen/go/coredocument"
	gocelery "github.com/centrifuge/gocelery/v2"

	mock "github.com/stretchr/testify/mock"

	types "github.com/centrifuge/go-substrate-rpc-client/v4/types"
)

// ServiceMock is an autogenerated mock type for the Service type
type ServiceMock struct {
	mock.Mock
}

// Commit provides a mock function with given fields: ctx, doc
func (_m *ServiceMock) Commit(ctx context.Context, doc Document) (gocelery.JobID, error) {
	ret := _m.Called(ctx, doc)

	var r0 gocelery.JobID
	if rf, ok := ret.Get(0).(func(context.Context, Document) gocelery.JobID); ok {
		r0 = rf(ctx, doc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gocelery.JobID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, Document) error); ok {
		r1 = rf(ctx, doc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProofs provides a mock function with given fields: ctx, documentID, fields
func (_m *ServiceMock) CreateProofs(ctx context.Context, documentID []byte, fields []string) (*DocumentProof, error) {
	ret := _m.Called(ctx, documentID, fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []string) *DocumentProof); ok {
		r0 = rf(ctx, documentID, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []string) error); ok {
		r1 = rf(ctx, documentID, fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProofsForVersion provides a mock function with given fields: ctx, documentID, version, fields
func (_m *ServiceMock) CreateProofsForVersion(ctx context.Context, documentID []byte, version []byte, fields []string) (*DocumentProof, error) {
	ret := _m.Called(ctx, documentID, version, fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte, []string) *DocumentProof); ok {
		r0 = rf(ctx, documentID, version, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte, []string) error); ok {
		r1 = rf(ctx, documentID, version, fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Derive provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) Derive(ctx context.Context, payload UpdatePayload) (Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, UpdatePayload) Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, UpdatePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeriveClone provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) DeriveClone(ctx context.Context, payload ClonePayload) (Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, ClonePayload) Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ClonePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeriveFromCoreDocument provides a mock function with given fields: cd
func (_m *ServiceMock) DeriveFromCoreDocument(cd *coredocumentpb.CoreDocument) (Document, error) {
	ret := _m.Called(cd)

	var r0 Document
	if rf, ok := ret.Get(0).(func(*coredocumentpb.CoreDocument) Document); ok {
		r0 = rf(cd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*coredocumentpb.CoreDocument) error); ok {
		r1 = rf(cd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentVersion provides a mock function with given fields: ctx, documentID
func (_m *ServiceMock) GetCurrentVersion(ctx context.Context, documentID []byte) (Document, error) {
	ret := _m.Called(ctx, documentID)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte) Document); ok {
		r0 = rf(ctx, documentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, documentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersion provides a mock function with given fields: ctx, documentID, version
func (_m *ServiceMock) GetVersion(ctx context.Context, documentID []byte, version []byte) (Document, error) {
	ret := _m.Called(ctx, documentID, version)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) Document); ok {
		r0 = rf(ctx, documentID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, documentID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// New provides a mock function with given fields: scheme
func (_m *ServiceMock) New(scheme string) (Document, error) {
	ret := _m.Called(scheme)

	var r0 Document
	if rf, ok := ret.Get(0).(func(string) Document); ok {
		r0 = rf(scheme)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(scheme)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReceiveAnchoredDocument provides a mock function with given fields: ctx, doc, collaborator
func (_m *ServiceMock) ReceiveAnchoredDocument(ctx context.Context, doc Document, collaborator *types.AccountID) error {
	ret := _m.Called(ctx, doc, collaborator)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Document, *types.AccountID) error); ok {
		r0 = rf(ctx, doc, collaborator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestDocumentSignature provides a mock function with given fields: ctx, doc, collaborator
func (_m *ServiceMock) RequestDocumentSignature(ctx context.Context, doc Document, collaborator *types.AccountID) ([]*coredocumentpb.Signature, error) {
	ret := _m.Called(ctx, doc, collaborator)

	var r0 []*coredocumentpb.Signature
	if rf, ok := ret.Get(0).(func(context.Context, Document, *types.AccountID) []*coredocumentpb.Signature); ok {
		r0 = rf(ctx, doc, collaborator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, Document, *types.AccountID) error); ok {
		r1 = rf(ctx, doc, collaborator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validate provides a mock function with given fields: ctx, doc, old
func (_m *ServiceMock) Validate(ctx context.Context, doc Document, old Document) error {
	ret := _m.Called(ctx, doc, old)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Document, Document) error); ok {
		r0 = rf(ctx, doc, old)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type NewServiceMockT interface {
	mock.TestingT
	Cleanup(func())
}

// NewServiceMock creates a new instance of ServiceMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewServiceMock(t NewServiceMockT) *ServiceMock {
	mock := &ServiceMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
