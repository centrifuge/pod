//go:build integration || unit || testworld
// +build integration unit testworld

package documents

import (
	"context"
	"reflect"
	"testing"
	"time"

	"github.com/centrifuge/gocelery/v2"

	coredocumentpb "github.com/centrifuge/centrifuge-protobufs/gen/go/coredocument"
	p2ppb "github.com/centrifuge/centrifuge-protobufs/gen/go/p2p"
	"github.com/centrifuge/go-centrifuge/errors"
	"github.com/centrifuge/go-centrifuge/identity"
	"github.com/centrifuge/go-centrifuge/storage"
	"github.com/centrifuge/go-substrate-rpc-client/v4/types"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/mock"
)

// GetTestCoreDocWithReset must only be used by tests for manipulations. It gets the embedded coredoc protobuf.
// All calls to this function will cause a regeneration of salts next time for precise-proof trees.
func (cd *CoreDocument) GetTestCoreDocWithReset() *coredocumentpb.CoreDocument {
	cd.Modified = true
	return &cd.Document
}

// DocumentMock is an autogenerated mock type for the Document type
type DocumentMock struct {
	mock.Mock
}

// ATGranteeCanRead provides a mock function with given fields: ctx, docSrv, idSrv, tokenID, docID, grantee
func (_m *DocumentMock) ATGranteeCanRead(ctx context.Context, docSrv Service, idSrv identity.Service, tokenID []byte, docID []byte, grantee identity.DID) error {
	ret := _m.Called(ctx, docSrv, idSrv, tokenID, docID, grantee)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Service, identity.Service, []byte, []byte, identity.DID) error); ok {
		r0 = rf(ctx, docSrv, idSrv, tokenID, docID, grantee)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AccountCanRead provides a mock function with given fields: account
func (_m *DocumentMock) AccountCanRead(account identity.DID) bool {
	ret := _m.Called(account)

	var r0 bool
	if rf, ok := ret.Get(0).(func(identity.DID) bool); ok {
		r0 = rf(account)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AddAttributes provides a mock function with given fields: ca, prepareNewVersion, attrs
func (_m *DocumentMock) AddAttributes(ca CollaboratorsAccess, prepareNewVersion bool, attrs ...Attribute) error {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ca, prepareNewVersion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(CollaboratorsAccess, bool, ...Attribute) error); ok {
		r0 = rf(ca, prepareNewVersion, attrs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddCcNft provides a mock function with given fields: classID, instanceID
func (_m *DocumentMock) AddCcNft(classID types.U64, instanceID types.U128) error {
	ret := _m.Called(classID, instanceID)

	var r0 error
	if rf, ok := ret.Get(0).(func(types.U64, types.U128) error); ok {
		r0 = rf(classID, instanceID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddComputeFieldsRule provides a mock function with given fields: wasm, fields, targetField
func (_m *DocumentMock) AddComputeFieldsRule(wasm []byte, fields []string, targetField string) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(wasm, fields, targetField)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte, []string, string) *coredocumentpb.TransitionRule); ok {
		r0 = rf(wasm, fields, targetField)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []string, string) error); ok {
		r1 = rf(wasm, fields, targetField)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddNFT provides a mock function with given fields: grantReadAccess, registry, tokenID, pad
func (_m *DocumentMock) AddNFT(grantReadAccess bool, registry common.Address, tokenID []byte, pad bool) error {
	ret := _m.Called(grantReadAccess, registry, tokenID, pad)

	var r0 error
	if rf, ok := ret.Get(0).(func(bool, common.Address, []byte, bool) error); ok {
		r0 = rf(grantReadAccess, registry, tokenID, pad)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddRole provides a mock function with given fields: key, collabs
func (_m *DocumentMock) AddRole(key string, collabs []identity.DID) (*coredocumentpb.Role, error) {
	ret := _m.Called(key, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func(string, []identity.DID) *coredocumentpb.Role); ok {
		r0 = rf(key, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []identity.DID) error); ok {
		r1 = rf(key, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTransitionRuleForAttribute provides a mock function with given fields: roleID, key
func (_m *DocumentMock) AddTransitionRuleForAttribute(roleID []byte, key AttrKey) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(roleID, key)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte, AttrKey) *coredocumentpb.TransitionRule); ok {
		r0 = rf(roleID, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, AttrKey) error); ok {
		r1 = rf(roleID, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddUpdateLog provides a mock function with given fields: account
func (_m *DocumentMock) AddUpdateLog(account identity.DID) error {
	ret := _m.Called(account)

	var r0 error
	if rf, ok := ret.Get(0).(func(identity.DID) error); ok {
		r0 = rf(account)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AnchorRepoAddress provides a mock function with given fields:
func (_m *DocumentMock) AnchorRepoAddress() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// AppendSignatures provides a mock function with given fields: signatures
func (_m *DocumentMock) AppendSignatures(signatures ...*coredocumentpb.Signature) {
	_va := make([]interface{}, len(signatures))
	for _i := range signatures {
		_va[_i] = signatures[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AttributeExists provides a mock function with given fields: key
func (_m *DocumentMock) AttributeExists(key AttrKey) bool {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(AttrKey) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Author provides a mock function with given fields:
func (_m *DocumentMock) Author() (identity.DID, error) {
	ret := _m.Called()

	var r0 identity.DID
	if rf, ok := ret.Get(0).(func() identity.DID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(identity.DID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateDocumentRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateDocumentRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateSignaturesRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateSignaturesRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateSigningRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateSigningRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateTransitionRulesFingerprint provides a mock function with given fields:
func (_m *DocumentMock) CalculateTransitionRulesFingerprint() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CcNfts provides a mock function with given fields:
func (_m *DocumentMock) CcNfts() []*coredocumentpb.CcNft {
	ret := _m.Called()

	var r0 []*coredocumentpb.CcNft
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.CcNft); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.CcNft)
		}
	}

	return r0
}

// CollaboratorCanUpdate provides a mock function with given fields: updated, collaborator
func (_m *DocumentMock) CollaboratorCanUpdate(updated Document, collaborator identity.DID) error {
	ret := _m.Called(updated, collaborator)

	var r0 error
	if rf, ok := ret.Get(0).(func(Document, identity.DID) error); ok {
		r0 = rf(updated, collaborator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateNFTProofs provides a mock function with given fields: account, registry, tokenID, nftUniqueProof, readAccessProof
func (_m *DocumentMock) CreateNFTProofs(account identity.DID, registry common.Address, tokenID []byte, nftUniqueProof bool, readAccessProof bool) (*DocumentProof, error) {
	ret := _m.Called(account, registry, tokenID, nftUniqueProof, readAccessProof)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func(identity.DID, common.Address, []byte, bool, bool) *DocumentProof); ok {
		r0 = rf(account, registry, tokenID, nftUniqueProof, readAccessProof)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(identity.DID, common.Address, []byte, bool, bool) error); ok {
		r1 = rf(account, registry, tokenID, nftUniqueProof, readAccessProof)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProofs provides a mock function with given fields: fields
func (_m *DocumentMock) CreateProofs(fields []string) (*DocumentProof, error) {
	ret := _m.Called(fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func([]string) *DocumentProof); ok {
		r0 = rf(fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CurrentVersion provides a mock function with given fields:
func (_m *DocumentMock) CurrentVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// CurrentVersionPreimage provides a mock function with given fields:
func (_m *DocumentMock) CurrentVersionPreimage() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// DeleteAttribute provides a mock function with given fields: key, prepareNewVersion
func (_m *DocumentMock) DeleteAttribute(key AttrKey, prepareNewVersion bool) error {
	ret := _m.Called(key, prepareNewVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(AttrKey, bool) error); ok {
		r0 = rf(key, prepareNewVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTransitionRule provides a mock function with given fields: ruleID
func (_m *DocumentMock) DeleteTransitionRule(ruleID []byte) error {
	ret := _m.Called(ruleID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(ruleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DocumentType provides a mock function with given fields:
func (_m *DocumentMock) DocumentType() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExecuteComputeFields provides a mock function with given fields: timeout
func (_m *DocumentMock) ExecuteComputeFields(timeout time.Duration) error {
	ret := _m.Called(timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FromJSON provides a mock function with given fields: json
func (_m *DocumentMock) FromJSON(json []byte) error {
	ret := _m.Called(json)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(json)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccessTokens provides a mock function with given fields:
func (_m *DocumentMock) GetAccessTokens() ([]*coredocumentpb.AccessToken, error) {
	ret := _m.Called()

	var r0 []*coredocumentpb.AccessToken
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.AccessToken); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.AccessToken)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttribute provides a mock function with given fields: key
func (_m *DocumentMock) GetAttribute(key AttrKey) (Attribute, error) {
	ret := _m.Called(key)

	var r0 Attribute
	if rf, ok := ret.Get(0).(func(AttrKey) Attribute); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(Attribute)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(AttrKey) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttributes provides a mock function with given fields:
func (_m *DocumentMock) GetAttributes() []Attribute {
	ret := _m.Called()

	var r0 []Attribute
	if rf, ok := ret.Get(0).(func() []Attribute); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Attribute)
		}
	}

	return r0
}

// GetCollaborators provides a mock function with given fields: filterIDs
func (_m *DocumentMock) GetCollaborators(filterIDs ...identity.DID) (CollaboratorsAccess, error) {
	_va := make([]interface{}, len(filterIDs))
	for _i := range filterIDs {
		_va[_i] = filterIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 CollaboratorsAccess
	if rf, ok := ret.Get(0).(func(...identity.DID) CollaboratorsAccess); ok {
		r0 = rf(filterIDs...)
	} else {
		r0 = ret.Get(0).(CollaboratorsAccess)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...identity.DID) error); ok {
		r1 = rf(filterIDs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComputeFieldsRules provides a mock function with given fields:
func (_m *DocumentMock) GetComputeFieldsRules() []*coredocumentpb.TransitionRule {
	ret := _m.Called()

	var r0 []*coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.TransitionRule); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.TransitionRule)
		}
	}

	return r0
}

// GetData provides a mock function with given fields:
func (_m *DocumentMock) GetData() interface{} {
	ret := _m.Called()

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetRole provides a mock function with given fields: key
func (_m *DocumentMock) GetRole(key []byte) (*coredocumentpb.Role, error) {
	ret := _m.Called(key)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func([]byte) *coredocumentpb.Role); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSignerCollaborators provides a mock function with given fields: filterIDs
func (_m *DocumentMock) GetSignerCollaborators(filterIDs ...identity.DID) ([]identity.DID, error) {
	_va := make([]interface{}, len(filterIDs))
	for _i := range filterIDs {
		_va[_i] = filterIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []identity.DID
	if rf, ok := ret.Get(0).(func(...identity.DID) []identity.DID); ok {
		r0 = rf(filterIDs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]identity.DID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...identity.DID) error); ok {
		r1 = rf(filterIDs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatus provides a mock function with given fields:
func (_m *DocumentMock) GetStatus() Status {
	ret := _m.Called()

	var r0 Status
	if rf, ok := ret.Get(0).(func() Status); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(Status)
	}

	return r0
}

// GetTransitionRule provides a mock function with given fields: ruleID
func (_m *DocumentMock) GetTransitionRule(ruleID []byte) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(ruleID)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte) *coredocumentpb.TransitionRule); ok {
		r0 = rf(ruleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(ruleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ID provides a mock function with given fields:
func (_m *DocumentMock) ID() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// IsDIDCollaborator provides a mock function with given fields: did
func (_m *DocumentMock) IsDIDCollaborator(did identity.DID) (bool, error) {
	ret := _m.Called(did)

	var r0 bool
	if rf, ok := ret.Get(0).(func(identity.DID) bool); ok {
		r0 = rf(did)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(identity.DID) error); ok {
		r1 = rf(did)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsNFTMinted provides a mock function with given fields: tr, registry
func (_m *DocumentMock) IsNFTMinted(tr TokenRegistry, registry common.Address) bool {
	ret := _m.Called(tr, registry)

	var r0 bool
	if rf, ok := ret.Get(0).(func(TokenRegistry, common.Address) bool); ok {
		r0 = rf(tr, registry)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// JSON provides a mock function with given fields:
func (_m *DocumentMock) JSON() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NFTOwnerCanRead provides a mock function with given fields: tokenRegistry, registry, tokenID, account
func (_m *DocumentMock) NFTOwnerCanRead(tokenRegistry TokenRegistry, registry common.Address, tokenID []byte, account identity.DID) error {
	ret := _m.Called(tokenRegistry, registry, tokenID, account)

	var r0 error
	if rf, ok := ret.Get(0).(func(TokenRegistry, common.Address, []byte, identity.DID) error); ok {
		r0 = rf(tokenRegistry, registry, tokenID, account)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NFTs provides a mock function with given fields:
func (_m *DocumentMock) NFTs() []*coredocumentpb.NFT {
	ret := _m.Called()

	var r0 []*coredocumentpb.NFT
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.NFT); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.NFT)
		}
	}

	return r0
}

// NextVersion provides a mock function with given fields:
func (_m *DocumentMock) NextVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// PackCoreDocument provides a mock function with given fields:
func (_m *DocumentMock) PackCoreDocument() (coredocumentpb.CoreDocument, error) {
	ret := _m.Called()

	var r0 coredocumentpb.CoreDocument
	if rf, ok := ret.Get(0).(func() coredocumentpb.CoreDocument); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(coredocumentpb.CoreDocument)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PreviousVersion provides a mock function with given fields:
func (_m *DocumentMock) PreviousVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// RemoveCollaborators provides a mock function with given fields: dids
func (_m *DocumentMock) RemoveCollaborators(dids []identity.DID) error {
	ret := _m.Called(dids)

	var r0 error
	if rf, ok := ret.Get(0).(func([]identity.DID) error); ok {
		r0 = rf(dids)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Scheme provides a mock function with given fields:
func (_m *DocumentMock) Scheme() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SetStatus provides a mock function with given fields: st
func (_m *DocumentMock) SetStatus(st Status) error {
	ret := _m.Called(st)

	var r0 error
	if rf, ok := ret.Get(0).(func(Status) error); ok {
		r0 = rf(st)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetUsedAnchorRepoAddress provides a mock function with given fields: addr
func (_m *DocumentMock) SetUsedAnchorRepoAddress(addr common.Address) {
	_m.Called(addr)
}

// Signatures provides a mock function with given fields:
func (_m *DocumentMock) Signatures() []coredocumentpb.Signature {
	ret := _m.Called()

	var r0 []coredocumentpb.Signature
	if rf, ok := ret.Get(0).(func() []coredocumentpb.Signature); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]coredocumentpb.Signature)
		}
	}

	return r0
}

// Timestamp provides a mock function with given fields:
func (_m *DocumentMock) Timestamp() (time.Time, error) {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields:
func (_m *DocumentMock) Type() reflect.Type {
	ret := _m.Called()

	var r0 reflect.Type
	if rf, ok := ret.Get(0).(func() reflect.Type); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(reflect.Type)
		}
	}

	return r0
}

// UnpackCoreDocument provides a mock function with given fields: cd
func (_m *DocumentMock) UnpackCoreDocument(cd coredocumentpb.CoreDocument) error {
	ret := _m.Called(cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(coredocumentpb.CoreDocument) error); ok {
		r0 = rf(cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRole provides a mock function with given fields: rk, collabs
func (_m *DocumentMock) UpdateRole(rk []byte, collabs []identity.DID) (*coredocumentpb.Role, error) {
	ret := _m.Called(rk, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func([]byte, []identity.DID) *coredocumentpb.Role); ok {
		r0 = rf(rk, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []identity.DID) error); ok {
		r1 = rf(rk, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Extra methods for implementing Patcher and Deriver

func (_m *DocumentMock) Patch(payload UpdatePayload) error {
	args := _m.Called(payload)
	return args.Error(0)
}

func (_m *DocumentMock) DeriveFromCreatePayload(ctx context.Context, payload CreatePayload) error {
	args := _m.Called(ctx, payload)
	return args.Error(0)
}

func (_m *DocumentMock) DeriveFromClonePayload(ctx context.Context, d Document) error {
	args := _m.Called(ctx, d)
	return args.Error(0)
}

func (_m *DocumentMock) DeriveFromUpdatePayload(ctx context.Context, payload UpdatePayload) (Document, error) {
	args := _m.Called(ctx, payload)
	doc, _ := args.Get(0).(Document)
	return doc, args.Error(1)
}

// NewDocumentMock creates a new instance of DocumentMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewDocumentMock(t testing.TB) *DocumentMock {
	mock := &DocumentMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// ServiceMock is an autogenerated mock type for the Service type
type ServiceMock struct {
	mock.Mock
}

// Commit provides a mock function with given fields: ctx, doc
func (_m *ServiceMock) Commit(ctx context.Context, doc Document) (gocelery.JobID, error) {
	ret := _m.Called(ctx, doc)

	var r0 gocelery.JobID
	if rf, ok := ret.Get(0).(func(context.Context, Document) gocelery.JobID); ok {
		r0 = rf(ctx, doc)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(gocelery.JobID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, Document) error); ok {
		r1 = rf(ctx, doc)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProofs provides a mock function with given fields: ctx, documentID, fields
func (_m *ServiceMock) CreateProofs(ctx context.Context, documentID []byte, fields []string) (*DocumentProof, error) {
	ret := _m.Called(ctx, documentID, fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []string) *DocumentProof); ok {
		r0 = rf(ctx, documentID, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []string) error); ok {
		r1 = rf(ctx, documentID, fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateProofsForVersion provides a mock function with given fields: ctx, documentID, version, fields
func (_m *ServiceMock) CreateProofsForVersion(ctx context.Context, documentID []byte, version []byte, fields []string) (*DocumentProof, error) {
	ret := _m.Called(ctx, documentID, version, fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte, []string) *DocumentProof); ok {
		r0 = rf(ctx, documentID, version, fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte, []string) error); ok {
		r1 = rf(ctx, documentID, version, fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Derive provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) Derive(ctx context.Context, payload UpdatePayload) (Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, UpdatePayload) Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, UpdatePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeriveClone provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) DeriveClone(ctx context.Context, payload ClonePayload) (Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, ClonePayload) Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ClonePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeriveFromCoreDocument provides a mock function with given fields: cd
func (_m *ServiceMock) DeriveFromCoreDocument(cd coredocumentpb.CoreDocument) (Document, error) {
	ret := _m.Called(cd)

	var r0 Document
	if rf, ok := ret.Get(0).(func(coredocumentpb.CoreDocument) Document); ok {
		r0 = rf(cd)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(coredocumentpb.CoreDocument) error); ok {
		r1 = rf(cd)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCurrentVersion provides a mock function with given fields: ctx, documentID
func (_m *ServiceMock) GetCurrentVersion(ctx context.Context, documentID []byte) (Document, error) {
	ret := _m.Called(ctx, documentID)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte) Document); ok {
		r0 = rf(ctx, documentID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, documentID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersion provides a mock function with given fields: ctx, documentID, version
func (_m *ServiceMock) GetVersion(ctx context.Context, documentID []byte, version []byte) (Document, error) {
	ret := _m.Called(ctx, documentID, version)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) Document); ok {
		r0 = rf(ctx, documentID, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, documentID, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// New provides a mock function with given fields: scheme
func (_m *ServiceMock) New(scheme string) (Document, error) {
	ret := _m.Called(scheme)

	var r0 Document
	if rf, ok := ret.Get(0).(func(string) Document); ok {
		r0 = rf(scheme)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(scheme)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReceiveAnchoredDocument provides a mock function with given fields: ctx, doc, collaborator
func (_m *ServiceMock) ReceiveAnchoredDocument(ctx context.Context, doc Document, collaborator identity.DID) error {
	ret := _m.Called(ctx, doc, collaborator)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Document, identity.DID) error); ok {
		r0 = rf(ctx, doc, collaborator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestDocumentSignature provides a mock function with given fields: ctx, doc, collaborator
func (_m *ServiceMock) RequestDocumentSignature(ctx context.Context, doc Document, collaborator identity.DID) ([]*coredocumentpb.Signature, error) {
	ret := _m.Called(ctx, doc, collaborator)

	var r0 []*coredocumentpb.Signature
	if rf, ok := ret.Get(0).(func(context.Context, Document, identity.DID) []*coredocumentpb.Signature); ok {
		r0 = rf(ctx, doc, collaborator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, Document, identity.DID) error); ok {
		r1 = rf(ctx, doc, collaborator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validate provides a mock function with given fields: ctx, doc, old
func (_m *ServiceMock) Validate(ctx context.Context, doc Document, old Document) error {
	ret := _m.Called(ctx, doc, old)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Document, Document) error); ok {
		r0 = rf(ctx, doc, old)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewServiceMock creates a new instance of ServiceMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewServiceMock(t testing.TB) *ServiceMock {
	mock := &ServiceMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// RepositoryMock is an autogenerated mock type for the Repository type
type RepositoryMock struct {
	mock.Mock
}

// Create provides a mock function with given fields: accountID, id, model
func (_m *RepositoryMock) Create(accountID []byte, id []byte, model Document) error {
	ret := _m.Called(accountID, id, model)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, Document) error); ok {
		r0 = rf(accountID, id, model)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Exists provides a mock function with given fields: accountID, id
func (_m *RepositoryMock) Exists(accountID []byte, id []byte) bool {
	ret := _m.Called(accountID, id)

	var r0 bool
	if rf, ok := ret.Get(0).(func([]byte, []byte) bool); ok {
		r0 = rf(accountID, id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Get provides a mock function with given fields: accountID, id
func (_m *RepositoryMock) Get(accountID []byte, id []byte) (Document, error) {
	ret := _m.Called(accountID, id)

	var r0 Document
	if rf, ok := ret.Get(0).(func([]byte, []byte) Document); ok {
		r0 = rf(accountID, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(accountID, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLatest provides a mock function with given fields: accountID, docID
func (_m *RepositoryMock) GetLatest(accountID []byte, docID []byte) (Document, error) {
	ret := _m.Called(accountID, docID)

	var r0 Document
	if rf, ok := ret.Get(0).(func([]byte, []byte) Document); ok {
		r0 = rf(accountID, docID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []byte) error); ok {
		r1 = rf(accountID, docID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Register provides a mock function with given fields: model
func (_m *RepositoryMock) Register(model Document) {
	_m.Called(model)
}

// Update provides a mock function with given fields: accountID, id, model
func (_m *RepositoryMock) Update(accountID []byte, id []byte, model Document) error {
	ret := _m.Called(accountID, id, model)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte, []byte, Document) error); ok {
		r0 = rf(accountID, id, model)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRepositoryMock creates a new instance of RepositoryMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewRepositoryMock(t testing.TB) *RepositoryMock {
	mock := &RepositoryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// TokenRegistryMock is an autogenerated mock type for the TokenRegistry type
type TokenRegistryMock struct {
	mock.Mock
}

// OwnerOf provides a mock function with given fields: registry, tokenID
func (_m *TokenRegistryMock) OwnerOf(registry common.Address, tokenID []byte) (common.Address, error) {
	ret := _m.Called(registry, tokenID)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(common.Address, []byte) common.Address); ok {
		r0 = rf(registry, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, []byte) error); ok {
		r1 = rf(registry, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OwnerOfOnCC provides a mock function with given fields: registry, tokenID
func (_m *TokenRegistryMock) OwnerOfOnCC(registry common.Address, tokenID []byte) (types.AccountID, error) {
	ret := _m.Called(registry, tokenID)

	var r0 types.AccountID
	if rf, ok := ret.Get(0).(func(common.Address, []byte) types.AccountID); ok {
		r0 = rf(registry, tokenID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(types.AccountID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Address, []byte) error); ok {
		r1 = rf(registry, tokenID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewTokenRegistryMock creates a new instance of TokenRegistryMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewTokenRegistryMock(t testing.TB) *TokenRegistryMock {
	mock := &TokenRegistryMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

func (b Bootstrapper) TestBootstrap(context map[string]interface{}) error {
	if _, ok := context[storage.BootstrappedDB]; !ok {
		return errors.New("initializing LevelDB repository failed")
	}
	return b.Bootstrap(context)
}

func (Bootstrapper) TestTearDown() error {
	return nil
}

func (b PostBootstrapper) TestBootstrap(ctx map[string]interface{}) error {
	return b.Bootstrap(ctx)
}

func (PostBootstrapper) TestTearDown() error {
	return nil
}

type MockRequestProcessor struct {
	mock.Mock
}

func (m *MockRequestProcessor) RequestDocumentWithAccessToken(ctx context.Context, granterDID identity.DID, tokenIdentifier,
	documentIdentifier, delegatingDocumentIdentifier []byte) (*p2ppb.GetDocumentResponse, error) {
	args := m.Called(granterDID, tokenIdentifier, documentIdentifier, delegatingDocumentIdentifier)
	resp, _ := args.Get(0).(*p2ppb.GetDocumentResponse)
	return resp, args.Error(1)
}
