// Code generated by mockery v2.13.0-beta.1. DO NOT EDIT.

package documents

import (
	context "context"

	coredocumentpb "github.com/centrifuge/centrifuge-protobufs/gen/go/coredocument"
	mock "github.com/stretchr/testify/mock"

	reflect "reflect"

	time "time"

	types "github.com/centrifuge/go-substrate-rpc-client/v4/types"

	v2 "github.com/centrifuge/go-centrifuge/identity/v2"
)

// DocumentMock is an autogenerated mock type for the Document type
type DocumentMock struct {
	mock.Mock
}

// ATGranteeCanRead provides a mock function with given fields: ctx, docSrv, identityService, tokenID, docID, grantee
func (_m *DocumentMock) ATGranteeCanRead(ctx context.Context, docSrv Service, identityService v2.Service, tokenID []byte, docID []byte, grantee *types.AccountID) error {
	ret := _m.Called(ctx, docSrv, identityService, tokenID, docID, grantee)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Service, v2.Service, []byte, []byte, *types.AccountID) error); ok {
		r0 = rf(ctx, docSrv, identityService, tokenID, docID, grantee)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AccountCanRead provides a mock function with given fields: accountID
func (_m *DocumentMock) AccountCanRead(accountID *types.AccountID) bool {
	ret := _m.Called(accountID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*types.AccountID) bool); ok {
		r0 = rf(accountID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// AddAttributes provides a mock function with given fields: ca, prepareNewVersion, attrs
func (_m *DocumentMock) AddAttributes(ca CollaboratorsAccess, prepareNewVersion bool, attrs ...Attribute) error {
	_va := make([]interface{}, len(attrs))
	for _i := range attrs {
		_va[_i] = attrs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ca, prepareNewVersion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(CollaboratorsAccess, bool, ...Attribute) error); ok {
		r0 = rf(ca, prepareNewVersion, attrs...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddComputeFieldsRule provides a mock function with given fields: wasm, fields, targetField
func (_m *DocumentMock) AddComputeFieldsRule(wasm []byte, fields []string, targetField string) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(wasm, fields, targetField)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte, []string, string) *coredocumentpb.TransitionRule); ok {
		r0 = rf(wasm, fields, targetField)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []string, string) error); ok {
		r1 = rf(wasm, fields, targetField)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddRole provides a mock function with given fields: key, collabs
func (_m *DocumentMock) AddRole(key string, collabs []*types.AccountID) (*coredocumentpb.Role, error) {
	ret := _m.Called(key, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func(string, []*types.AccountID) *coredocumentpb.Role); ok {
		r0 = rf(key, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []*types.AccountID) error); ok {
		r1 = rf(key, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTransitionRuleForAttribute provides a mock function with given fields: roleID, key
func (_m *DocumentMock) AddTransitionRuleForAttribute(roleID []byte, key AttrKey) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(roleID, key)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte, AttrKey) *coredocumentpb.TransitionRule); ok {
		r0 = rf(roleID, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, AttrKey) error); ok {
		r1 = rf(roleID, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddUpdateLog provides a mock function with given fields: accountID
func (_m *DocumentMock) AddUpdateLog(accountID *types.AccountID) error {
	ret := _m.Called(accountID)

	var r0 error
	if rf, ok := ret.Get(0).(func(*types.AccountID) error); ok {
		r0 = rf(accountID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendSignatures provides a mock function with given fields: signatures
func (_m *DocumentMock) AppendSignatures(signatures ...*coredocumentpb.Signature) {
	_va := make([]interface{}, len(signatures))
	for _i := range signatures {
		_va[_i] = signatures[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AttributeExists provides a mock function with given fields: key
func (_m *DocumentMock) AttributeExists(key AttrKey) bool {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(AttrKey) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// Author provides a mock function with given fields:
func (_m *DocumentMock) Author() (*types.AccountID, error) {
	ret := _m.Called()

	var r0 *types.AccountID
	if rf, ok := ret.Get(0).(func() *types.AccountID); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.AccountID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateDocumentRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateDocumentRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateSignaturesRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateSignaturesRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateSigningRoot provides a mock function with given fields:
func (_m *DocumentMock) CalculateSigningRoot() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CalculateTransitionRulesFingerprint provides a mock function with given fields:
func (_m *DocumentMock) CalculateTransitionRulesFingerprint() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CollaboratorCanUpdate provides a mock function with given fields: updated, collaborator
func (_m *DocumentMock) CollaboratorCanUpdate(updated Document, collaborator *types.AccountID) error {
	ret := _m.Called(updated, collaborator)

	var r0 error
	if rf, ok := ret.Get(0).(func(Document, *types.AccountID) error); ok {
		r0 = rf(updated, collaborator)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateProofs provides a mock function with given fields: fields
func (_m *DocumentMock) CreateProofs(fields []string) (*DocumentProof, error) {
	ret := _m.Called(fields)

	var r0 *DocumentProof
	if rf, ok := ret.Get(0).(func([]string) *DocumentProof); ok {
		r0 = rf(fields)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*DocumentProof)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]string) error); ok {
		r1 = rf(fields)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CurrentVersion provides a mock function with given fields:
func (_m *DocumentMock) CurrentVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// CurrentVersionPreimage provides a mock function with given fields:
func (_m *DocumentMock) CurrentVersionPreimage() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// DeleteAttribute provides a mock function with given fields: key, prepareNewVersion
func (_m *DocumentMock) DeleteAttribute(key AttrKey, prepareNewVersion bool) error {
	ret := _m.Called(key, prepareNewVersion)

	var r0 error
	if rf, ok := ret.Get(0).(func(AttrKey, bool) error); ok {
		r0 = rf(key, prepareNewVersion)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTransitionRule provides a mock function with given fields: ruleID
func (_m *DocumentMock) DeleteTransitionRule(ruleID []byte) error {
	ret := _m.Called(ruleID)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(ruleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeriveFromClonePayload provides a mock function with given fields: ctx, m
func (_m *DocumentMock) DeriveFromClonePayload(ctx context.Context, m Document) error {
	ret := _m.Called(ctx, m)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, Document) error); ok {
		r0 = rf(ctx, m)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeriveFromCreatePayload provides a mock function with given fields: ctx, payload
func (_m *DocumentMock) DeriveFromCreatePayload(ctx context.Context, payload CreatePayload) error {
	ret := _m.Called(ctx, payload)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, CreatePayload) error); ok {
		r0 = rf(ctx, payload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeriveFromUpdatePayload provides a mock function with given fields: ctx, payload
func (_m *DocumentMock) DeriveFromUpdatePayload(ctx context.Context, payload UpdatePayload) (Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 Document
	if rf, ok := ret.Get(0).(func(context.Context, UpdatePayload) Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, UpdatePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DocumentType provides a mock function with given fields:
func (_m *DocumentMock) DocumentType() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ExecuteComputeFields provides a mock function with given fields: timeout
func (_m *DocumentMock) ExecuteComputeFields(timeout time.Duration) error {
	ret := _m.Called(timeout)

	var r0 error
	if rf, ok := ret.Get(0).(func(time.Duration) error); ok {
		r0 = rf(timeout)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// FromJSON provides a mock function with given fields: json
func (_m *DocumentMock) FromJSON(json []byte) error {
	ret := _m.Called(json)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(json)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAccessTokens provides a mock function with given fields:
func (_m *DocumentMock) GetAccessTokens() ([]*coredocumentpb.AccessToken, error) {
	ret := _m.Called()

	var r0 []*coredocumentpb.AccessToken
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.AccessToken); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.AccessToken)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttribute provides a mock function with given fields: key
func (_m *DocumentMock) GetAttribute(key AttrKey) (Attribute, error) {
	ret := _m.Called(key)

	var r0 Attribute
	if rf, ok := ret.Get(0).(func(AttrKey) Attribute); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(Attribute)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(AttrKey) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAttributes provides a mock function with given fields:
func (_m *DocumentMock) GetAttributes() []Attribute {
	ret := _m.Called()

	var r0 []Attribute
	if rf, ok := ret.Get(0).(func() []Attribute); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Attribute)
		}
	}

	return r0
}

// GetCollaborators provides a mock function with given fields: filterIDs
func (_m *DocumentMock) GetCollaborators(filterIDs ...*types.AccountID) (CollaboratorsAccess, error) {
	_va := make([]interface{}, len(filterIDs))
	for _i := range filterIDs {
		_va[_i] = filterIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 CollaboratorsAccess
	if rf, ok := ret.Get(0).(func(...*types.AccountID) CollaboratorsAccess); ok {
		r0 = rf(filterIDs...)
	} else {
		r0 = ret.Get(0).(CollaboratorsAccess)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...*types.AccountID) error); ok {
		r1 = rf(filterIDs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetComputeFieldsRules provides a mock function with given fields:
func (_m *DocumentMock) GetComputeFieldsRules() []*coredocumentpb.TransitionRule {
	ret := _m.Called()

	var r0 []*coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.TransitionRule); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.TransitionRule)
		}
	}

	return r0
}

// GetData provides a mock function with given fields:
func (_m *DocumentMock) GetData() interface{} {
	ret := _m.Called()

	var r0 interface{}
	if rf, ok := ret.Get(0).(func() interface{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetRole provides a mock function with given fields: key
func (_m *DocumentMock) GetRole(key []byte) (*coredocumentpb.Role, error) {
	ret := _m.Called(key)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func([]byte) *coredocumentpb.Role); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSignerCollaborators provides a mock function with given fields: filterIDs
func (_m *DocumentMock) GetSignerCollaborators(filterIDs ...*types.AccountID) ([]*types.AccountID, error) {
	_va := make([]interface{}, len(filterIDs))
	for _i := range filterIDs {
		_va[_i] = filterIDs[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []*types.AccountID
	if rf, ok := ret.Get(0).(func(...*types.AccountID) []*types.AccountID); ok {
		r0 = rf(filterIDs...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*types.AccountID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...*types.AccountID) error); ok {
		r1 = rf(filterIDs...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStatus provides a mock function with given fields:
func (_m *DocumentMock) GetStatus() Status {
	ret := _m.Called()

	var r0 Status
	if rf, ok := ret.Get(0).(func() Status); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(Status)
	}

	return r0
}

// GetTransitionRule provides a mock function with given fields: ruleID
func (_m *DocumentMock) GetTransitionRule(ruleID []byte) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(ruleID)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func([]byte) *coredocumentpb.TransitionRule); ok {
		r0 = rf(ruleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(ruleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ID provides a mock function with given fields:
func (_m *DocumentMock) ID() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// IsCollaborator provides a mock function with given fields: accountID
func (_m *DocumentMock) IsCollaborator(accountID *types.AccountID) (bool, error) {
	ret := _m.Called(accountID)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*types.AccountID) bool); ok {
		r0 = rf(accountID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*types.AccountID) error); ok {
		r1 = rf(accountID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// JSON provides a mock function with given fields:
func (_m *DocumentMock) JSON() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NFTs provides a mock function with given fields:
func (_m *DocumentMock) NFTs() []*coredocumentpb.NFT {
	ret := _m.Called()

	var r0 []*coredocumentpb.NFT
	if rf, ok := ret.Get(0).(func() []*coredocumentpb.NFT); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.NFT)
		}
	}

	return r0
}

// NextVersion provides a mock function with given fields:
func (_m *DocumentMock) NextVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// PackCoreDocument provides a mock function with given fields:
func (_m *DocumentMock) PackCoreDocument() (coredocumentpb.CoreDocument, error) {
	ret := _m.Called()

	var r0 coredocumentpb.CoreDocument
	if rf, ok := ret.Get(0).(func() coredocumentpb.CoreDocument); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(coredocumentpb.CoreDocument)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Patch provides a mock function with given fields: payload
func (_m *DocumentMock) Patch(payload UpdatePayload) error {
	ret := _m.Called(payload)

	var r0 error
	if rf, ok := ret.Get(0).(func(UpdatePayload) error); ok {
		r0 = rf(payload)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PreviousVersion provides a mock function with given fields:
func (_m *DocumentMock) PreviousVersion() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// RemoveCollaborators provides a mock function with given fields: collaboratorAccountIDs
func (_m *DocumentMock) RemoveCollaborators(collaboratorAccountIDs []*types.AccountID) error {
	ret := _m.Called(collaboratorAccountIDs)

	var r0 error
	if rf, ok := ret.Get(0).(func([]*types.AccountID) error); ok {
		r0 = rf(collaboratorAccountIDs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Scheme provides a mock function with given fields:
func (_m *DocumentMock) Scheme() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// SetStatus provides a mock function with given fields: st
func (_m *DocumentMock) SetStatus(st Status) error {
	ret := _m.Called(st)

	var r0 error
	if rf, ok := ret.Get(0).(func(Status) error); ok {
		r0 = rf(st)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Signatures provides a mock function with given fields:
func (_m *DocumentMock) Signatures() []coredocumentpb.Signature {
	ret := _m.Called()

	var r0 []coredocumentpb.Signature
	if rf, ok := ret.Get(0).(func() []coredocumentpb.Signature); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]coredocumentpb.Signature)
		}
	}

	return r0
}

// Timestamp provides a mock function with given fields:
func (_m *DocumentMock) Timestamp() (time.Time, error) {
	ret := _m.Called()

	var r0 time.Time
	if rf, ok := ret.Get(0).(func() time.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields:
func (_m *DocumentMock) Type() reflect.Type {
	ret := _m.Called()

	var r0 reflect.Type
	if rf, ok := ret.Get(0).(func() reflect.Type); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(reflect.Type)
		}
	}

	return r0
}

// UnpackCoreDocument provides a mock function with given fields: cd
func (_m *DocumentMock) UnpackCoreDocument(cd coredocumentpb.CoreDocument) error {
	ret := _m.Called(cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(coredocumentpb.CoreDocument) error); ok {
		r0 = rf(cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateRole provides a mock function with given fields: rk, collabs
func (_m *DocumentMock) UpdateRole(rk []byte, collabs []*types.AccountID) (*coredocumentpb.Role, error) {
	ret := _m.Called(rk, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func([]byte, []*types.AccountID) *coredocumentpb.Role); ok {
		r0 = rf(rk, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, []*types.AccountID) error); ok {
		r1 = rf(rk, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type NewDocumentMockT interface {
	mock.TestingT
	Cleanup(func())
}

// NewDocumentMock creates a new instance of DocumentMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewDocumentMock(t NewDocumentMockT) *DocumentMock {
	mock := &DocumentMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
