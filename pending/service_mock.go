// Code generated by mockery v2.13.0-beta.1. DO NOT EDIT.

package pending

import (
	context "context"

	coredocumentpb "github.com/centrifuge/centrifuge-protobufs/gen/go/coredocument"
	documents "github.com/centrifuge/go-centrifuge/documents"

	gocelery "github.com/centrifuge/gocelery/v2"

	mock "github.com/stretchr/testify/mock"

	types "github.com/centrifuge/go-substrate-rpc-client/v4/types"
)

// ServiceMock is an autogenerated mock type for the Service type
type ServiceMock struct {
	mock.Mock
}

// AddAttributes provides a mock function with given fields: ctx, docID, attrs
func (_m *ServiceMock) AddAttributes(ctx context.Context, docID []byte, attrs []documents.Attribute) (documents.Document, error) {
	ret := _m.Called(ctx, docID, attrs)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []documents.Attribute) documents.Document); ok {
		r0 = rf(ctx, docID, attrs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []documents.Attribute) error); ok {
		r1 = rf(ctx, docID, attrs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddRole provides a mock function with given fields: ctx, docID, roleKey, collabs
func (_m *ServiceMock) AddRole(ctx context.Context, docID []byte, roleKey string, collabs []*types.AccountID) (*coredocumentpb.Role, error) {
	ret := _m.Called(ctx, docID, roleKey, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string, []*types.AccountID) *coredocumentpb.Role); ok {
		r0 = rf(ctx, docID, roleKey, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, string, []*types.AccountID) error); ok {
		r1 = rf(ctx, docID, roleKey, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddSignedAttribute provides a mock function with given fields: ctx, docID, label, value, valType
func (_m *ServiceMock) AddSignedAttribute(ctx context.Context, docID []byte, label string, value []byte, valType documents.AttributeType) (documents.Document, error) {
	ret := _m.Called(ctx, docID, label, value, valType)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, string, []byte, documents.AttributeType) documents.Document); ok {
		r0 = rf(ctx, docID, label, value, valType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, string, []byte, documents.AttributeType) error); ok {
		r1 = rf(ctx, docID, label, value, valType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddTransitionRules provides a mock function with given fields: ctx, docID, addRules
func (_m *ServiceMock) AddTransitionRules(ctx context.Context, docID []byte, addRules AddTransitionRules) ([]*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(ctx, docID, addRules)

	var r0 []*coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func(context.Context, []byte, AddTransitionRules) []*coredocumentpb.TransitionRule); ok {
		r0 = rf(ctx, docID, addRules)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, AddTransitionRules) error); ok {
		r1 = rf(ctx, docID, addRules)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Clone provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) Clone(ctx context.Context, payload documents.ClonePayload) (documents.Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, documents.ClonePayload) documents.Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, documents.ClonePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Commit provides a mock function with given fields: ctx, docID
func (_m *ServiceMock) Commit(ctx context.Context, docID []byte) (documents.Document, gocelery.JobID, error) {
	ret := _m.Called(ctx, docID)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte) documents.Document); ok {
		r0 = rf(ctx, docID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 gocelery.JobID
	if rf, ok := ret.Get(1).(func(context.Context, []byte) gocelery.JobID); ok {
		r1 = rf(ctx, docID)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(gocelery.JobID)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []byte) error); ok {
		r2 = rf(ctx, docID)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Create provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) Create(ctx context.Context, payload documents.UpdatePayload) (documents.Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, documents.UpdatePayload) documents.Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, documents.UpdatePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAttribute provides a mock function with given fields: ctx, docID, key
func (_m *ServiceMock) DeleteAttribute(ctx context.Context, docID []byte, key documents.AttrKey) (documents.Document, error) {
	ret := _m.Called(ctx, docID, key)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, documents.AttrKey) documents.Document); ok {
		r0 = rf(ctx, docID, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, documents.AttrKey) error); ok {
		r1 = rf(ctx, docID, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTransitionRule provides a mock function with given fields: ctx, docID, ruleID
func (_m *ServiceMock) DeleteTransitionRule(ctx context.Context, docID []byte, ruleID []byte) error {
	ret := _m.Called(ctx, docID, ruleID)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) error); ok {
		r0 = rf(ctx, docID, ruleID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, docID, status
func (_m *ServiceMock) Get(ctx context.Context, docID []byte, status documents.Status) (documents.Document, error) {
	ret := _m.Called(ctx, docID, status)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, documents.Status) documents.Document); ok {
		r0 = rf(ctx, docID, status)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, documents.Status) error); ok {
		r1 = rf(ctx, docID, status)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRole provides a mock function with given fields: ctx, docID, roleID
func (_m *ServiceMock) GetRole(ctx context.Context, docID []byte, roleID []byte) (*coredocumentpb.Role, error) {
	ret := _m.Called(ctx, docID, roleID)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) *coredocumentpb.Role); ok {
		r0 = rf(ctx, docID, roleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, docID, roleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransitionRule provides a mock function with given fields: ctx, docID, ruleID
func (_m *ServiceMock) GetTransitionRule(ctx context.Context, docID []byte, ruleID []byte) (*coredocumentpb.TransitionRule, error) {
	ret := _m.Called(ctx, docID, ruleID)

	var r0 *coredocumentpb.TransitionRule
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) *coredocumentpb.TransitionRule); ok {
		r0 = rf(ctx, docID, ruleID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.TransitionRule)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, docID, ruleID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVersion provides a mock function with given fields: ctx, docID, versionID
func (_m *ServiceMock) GetVersion(ctx context.Context, docID []byte, versionID []byte) (documents.Document, error) {
	ret := _m.Called(ctx, docID, versionID)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte) documents.Document); ok {
		r0 = rf(ctx, docID, versionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte) error); ok {
		r1 = rf(ctx, docID, versionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RemoveCollaborators provides a mock function with given fields: ctx, docID, dids
func (_m *ServiceMock) RemoveCollaborators(ctx context.Context, docID []byte, dids []*types.AccountID) (documents.Document, error) {
	ret := _m.Called(ctx, docID, dids)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []*types.AccountID) documents.Document); ok {
		r0 = rf(ctx, docID, dids)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []*types.AccountID) error); ok {
		r1 = rf(ctx, docID, dids)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, payload
func (_m *ServiceMock) Update(ctx context.Context, payload documents.UpdatePayload) (documents.Document, error) {
	ret := _m.Called(ctx, payload)

	var r0 documents.Document
	if rf, ok := ret.Get(0).(func(context.Context, documents.UpdatePayload) documents.Document); ok {
		r0 = rf(ctx, payload)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(documents.Document)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, documents.UpdatePayload) error); ok {
		r1 = rf(ctx, payload)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateRole provides a mock function with given fields: ctx, docID, roleID, collabs
func (_m *ServiceMock) UpdateRole(ctx context.Context, docID []byte, roleID []byte, collabs []*types.AccountID) (*coredocumentpb.Role, error) {
	ret := _m.Called(ctx, docID, roleID, collabs)

	var r0 *coredocumentpb.Role
	if rf, ok := ret.Get(0).(func(context.Context, []byte, []byte, []*types.AccountID) *coredocumentpb.Role); ok {
		r0 = rf(ctx, docID, roleID, collabs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Role)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, []byte, []*types.AccountID) error); ok {
		r1 = rf(ctx, docID, roleID, collabs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type NewServiceMockT interface {
	mock.TestingT
	Cleanup(func())
}

// NewServiceMock creates a new instance of ServiceMock. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewServiceMock(t NewServiceMockT) *ServiceMock {
	mock := &ServiceMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
