//go:build integration || unit
// +build integration unit

package config

import (
	"fmt"
	"math/big"
	"os"
	"path"
	"reflect"
	"testing"
	"time"

	coredocumentpb "github.com/centrifuge/centrifuge-protobufs/gen/go/coredocument"
	"github.com/centrifuge/go-centrifuge/bootstrap"
	"github.com/ethereum/go-ethereum/common"
	"github.com/stretchr/testify/mock"
)

func (*Bootstrapper) TestBootstrap(context map[string]interface{}) error {
	if _, ok := context[bootstrap.BootstrappedConfig]; ok {
		return nil
	}
	// To get the config location, we need to traverse the path to find the `go-centrifuge` folder
	gp := os.Getenv("BASE_PATH")
	projDir := path.Join(gp, "centrifuge", "go-centrifuge")
	context[bootstrap.BootstrappedConfig] = LoadConfiguration(fmt.Sprintf("%s/build/configs/testing_yaml", projDir))
	return nil
}

func (b *Bootstrapper) TestTearDown() error {
	return nil
}

// ConfigurationMock is an autogenerated mock type for the Configuration type
type ConfigurationMock struct {
	mock.Mock
}

// FromJSON provides a mock function with given fields: json
func (_m *ConfigurationMock) FromJSON(json []byte) error {
	ret := _m.Called(json)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(json)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: key
func (_m *ConfigurationMock) Get(key string) interface{} {
	ret := _m.Called(key)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetAccountsKeystore provides a mock function with given fields:
func (_m *ConfigurationMock) GetAccountsKeystore() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetBool provides a mock function with given fields: key
func (_m *ConfigurationMock) GetBool(key string) bool {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetBootstrapPeers provides a mock function with given fields:
func (_m *ConfigurationMock) GetBootstrapPeers() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetCentChainAccount provides a mock function with given fields:
func (_m *ConfigurationMock) GetCentChainAccount() (CentChainAccount, error) {
	ret := _m.Called()

	var r0 CentChainAccount
	if rf, ok := ret.Get(0).(func() CentChainAccount); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(CentChainAccount)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCentChainAnchorLifespan provides a mock function with given fields:
func (_m *ConfigurationMock) GetCentChainAnchorLifespan() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetCentChainIntervalRetry provides a mock function with given fields:
func (_m *ConfigurationMock) GetCentChainIntervalRetry() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetCentChainMaxRetries provides a mock function with given fields:
func (_m *ConfigurationMock) GetCentChainMaxRetries() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetCentChainNodeURL provides a mock function with given fields:
func (_m *ConfigurationMock) GetCentChainNodeURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetConfigStoragePath provides a mock function with given fields:
func (_m *ConfigurationMock) GetConfigStoragePath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetContractAddress provides a mock function with given fields: contractName
func (_m *ConfigurationMock) GetContractAddress(contractName ContractName) common.Address {
	ret := _m.Called(contractName)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(ContractName) common.Address); ok {
		r0 = rf(contractName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// GetContractAddressString provides a mock function with given fields: address
func (_m *ConfigurationMock) GetContractAddressString(address string) string {
	ret := _m.Called(address)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(address)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetDuration provides a mock function with given fields: key
func (_m *ConfigurationMock) GetDuration(key string) time.Duration {
	ret := _m.Called(key)

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func(string) time.Duration); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetEthereumAccount provides a mock function with given fields: accountName
func (_m *ConfigurationMock) GetEthereumAccount(accountName string) (*AccountConfig, error) {
	ret := _m.Called(accountName)

	var r0 *AccountConfig
	if rf, ok := ret.Get(0).(func(string) *AccountConfig); ok {
		r0 = rf(accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AccountConfig)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEthereumContextReadWaitTimeout provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumContextReadWaitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetEthereumContextWaitTimeout provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumContextWaitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetEthereumDefaultAccountName provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumDefaultAccountName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetEthereumGasLimit provides a mock function with given fields: op
func (_m *ConfigurationMock) GetEthereumGasLimit(op ContractOp) uint64 {
	ret := _m.Called(op)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(ContractOp) uint64); ok {
		r0 = rf(op)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	return r0
}

// GetEthereumGasMultiplier provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumGasMultiplier() float64 {
	ret := _m.Called()

	var r0 float64
	if rf, ok := ret.Get(0).(func() float64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(float64)
	}

	return r0
}

// GetEthereumIntervalRetry provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumIntervalRetry() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetEthereumMaxGasPrice provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumMaxGasPrice() *big.Int {
	ret := _m.Called()

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func() *big.Int); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	return r0
}

// GetEthereumMaxRetries provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumMaxRetries() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetEthereumNodeURL provides a mock function with given fields:
func (_m *ConfigurationMock) GetEthereumNodeURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetFloat provides a mock function with given fields: key
func (_m *ConfigurationMock) GetFloat(key string) float64 {
	ret := _m.Called(key)

	var r0 float64
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(float64)
	}

	return r0
}

// GetIFPSBootstrapPeers provides a mock function with given fields:
func (_m *ConfigurationMock) GetIFPSBootstrapPeers() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

// GetIPFSPluginsPath provides a mock function with given fields:
func (_m *ConfigurationMock) GetIPFSPluginsPath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetIdentityID provides a mock function with given fields:
func (_m *ConfigurationMock) GetIdentityID() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInt provides a mock function with given fields: key
func (_m *ConfigurationMock) GetInt(key string) int {
	ret := _m.Called(key)

	var r0 int
	if rf, ok := ret.Get(0).(func(string) int); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetNetworkID provides a mock function with given fields:
func (_m *ConfigurationMock) GetNetworkID() uint32 {
	ret := _m.Called()

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// GetNetworkKey provides a mock function with given fields: k
func (_m *ConfigurationMock) GetNetworkKey(k string) string {
	ret := _m.Called(k)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(k)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetNetworkString provides a mock function with given fields:
func (_m *ConfigurationMock) GetNetworkString() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetNumWorkers provides a mock function with given fields:
func (_m *ConfigurationMock) GetNumWorkers() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetP2PConnectionTimeout provides a mock function with given fields:
func (_m *ConfigurationMock) GetP2PConnectionTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetP2PExternalIP provides a mock function with given fields:
func (_m *ConfigurationMock) GetP2PExternalIP() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetP2PKeyPair provides a mock function with given fields:
func (_m *ConfigurationMock) GetP2PKeyPair() (string, string) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetP2PPort provides a mock function with given fields:
func (_m *ConfigurationMock) GetP2PPort() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetP2PResponseDelay provides a mock function with given fields:
func (_m *ConfigurationMock) GetP2PResponseDelay() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetPrecommitEnabled provides a mock function with given fields:
func (_m *ConfigurationMock) GetPrecommitEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetReceiveEventNotificationEndpoint provides a mock function with given fields:
func (_m *ConfigurationMock) GetReceiveEventNotificationEndpoint() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetServerAddress provides a mock function with given fields:
func (_m *ConfigurationMock) GetServerAddress() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetServerPort provides a mock function with given fields:
func (_m *ConfigurationMock) GetServerPort() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetSigningKeyPair provides a mock function with given fields:
func (_m *ConfigurationMock) GetSigningKeyPair() (string, string) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetStoragePath provides a mock function with given fields:
func (_m *ConfigurationMock) GetStoragePath() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetString provides a mock function with given fields: key
func (_m *ConfigurationMock) GetString(key string) string {
	ret := _m.Called(key)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetTaskValidDuration provides a mock function with given fields:
func (_m *ConfigurationMock) GetTaskValidDuration() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetWorkerWaitTimeMS provides a mock function with given fields:
func (_m *ConfigurationMock) GetWorkerWaitTimeMS() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// IsDebugLogEnabled provides a mock function with given fields:
func (_m *ConfigurationMock) IsDebugLogEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsPProfEnabled provides a mock function with given fields:
func (_m *ConfigurationMock) IsPProfEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// IsSet provides a mock function with given fields: key
func (_m *ConfigurationMock) IsSet(key string) bool {
	ret := _m.Called(key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// JSON provides a mock function with given fields:
func (_m *ConfigurationMock) JSON() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Set provides a mock function with given fields: key, value
func (_m *ConfigurationMock) Set(key string, value interface{}) {
	_m.Called(key, value)
}

// SetDefault provides a mock function with given fields: key, value
func (_m *ConfigurationMock) SetDefault(key string, value interface{}) {
	_m.Called(key, value)
}

// SetupSmartContractAddresses provides a mock function with given fields: network, smartContractAddresses
func (_m *ConfigurationMock) SetupSmartContractAddresses(network string, smartContractAddresses *SmartContractAddresses) {
	_m.Called(network, smartContractAddresses)
}

// Type provides a mock function with given fields:
func (_m *ConfigurationMock) Type() reflect.Type {
	ret := _m.Called()

	var r0 reflect.Type
	if rf, ok := ret.Get(0).(func() reflect.Type); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(reflect.Type)
		}
	}

	return r0
}

// NewConfigurationMock creates a new instance of ConfigurationMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewConfigurationMock(t testing.TB) *ConfigurationMock {
	mock := &ConfigurationMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// AccountMock is an autogenerated mock type for the Account type
type AccountMock struct {
	mock.Mock
}

// FromJSON provides a mock function with given fields: json
func (_m *AccountMock) FromJSON(json []byte) error {
	ret := _m.Called(json)

	var r0 error
	if rf, ok := ret.Get(0).(func([]byte) error); ok {
		r0 = rf(json)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCentChainAccount provides a mock function with given fields:
func (_m *AccountMock) GetCentChainAccount() CentChainAccount {
	ret := _m.Called()

	var r0 CentChainAccount
	if rf, ok := ret.Get(0).(func() CentChainAccount); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(CentChainAccount)
	}

	return r0
}

// GetEthereumAccount provides a mock function with given fields:
func (_m *AccountMock) GetEthereumAccount() *AccountConfig {
	ret := _m.Called()

	var r0 *AccountConfig
	if rf, ok := ret.Get(0).(func() *AccountConfig); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*AccountConfig)
		}
	}

	return r0
}

// GetEthereumContextWaitTimeout provides a mock function with given fields:
func (_m *AccountMock) GetEthereumContextWaitTimeout() time.Duration {
	ret := _m.Called()

	var r0 time.Duration
	if rf, ok := ret.Get(0).(func() time.Duration); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(time.Duration)
	}

	return r0
}

// GetEthereumDefaultAccountName provides a mock function with given fields:
func (_m *AccountMock) GetEthereumDefaultAccountName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetIdentityID provides a mock function with given fields:
func (_m *AccountMock) GetIdentityID() []byte {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// GetKeys provides a mock function with given fields:
func (_m *AccountMock) GetKeys() (map[string]IDKey, error) {
	ret := _m.Called()

	var r0 map[string]IDKey
	if rf, ok := ret.Get(0).(func() map[string]IDKey); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]IDKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetP2PKeyPair provides a mock function with given fields:
func (_m *AccountMock) GetP2PKeyPair() (string, string) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// GetPrecommitEnabled provides a mock function with given fields:
func (_m *AccountMock) GetPrecommitEnabled() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetReceiveEventNotificationEndpoint provides a mock function with given fields:
func (_m *AccountMock) GetReceiveEventNotificationEndpoint() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetSigningKeyPair provides a mock function with given fields:
func (_m *AccountMock) GetSigningKeyPair() (string, string) {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 string
	if rf, ok := ret.Get(1).(func() string); ok {
		r1 = rf()
	} else {
		r1 = ret.Get(1).(string)
	}

	return r0, r1
}

// JSON provides a mock function with given fields:
func (_m *AccountMock) JSON() ([]byte, error) {
	ret := _m.Called()

	var r0 []byte
	if rf, ok := ret.Get(0).(func() []byte); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignMsg provides a mock function with given fields: msg
func (_m *AccountMock) SignMsg(msg []byte) (*coredocumentpb.Signature, error) {
	ret := _m.Called(msg)

	var r0 *coredocumentpb.Signature
	if rf, ok := ret.Get(0).(func([]byte) *coredocumentpb.Signature); ok {
		r0 = rf(msg)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coredocumentpb.Signature)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte) error); ok {
		r1 = rf(msg)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Type provides a mock function with given fields:
func (_m *AccountMock) Type() reflect.Type {
	ret := _m.Called()

	var r0 reflect.Type
	if rf, ok := ret.Get(0).(func() reflect.Type); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(reflect.Type)
		}
	}

	return r0
}

// NewAccountMock creates a new instance of AccountMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewAccountMock(t testing.TB) *AccountMock {
	mock := &AccountMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

type MockService struct {
	mock.Mock
	Service
}

func (m *MockService) GenerateAccount(cacc CentChainAccount) (Account, error) {
	args := m.Called(cacc)
	acc, _ := args.Get(0).(Account)
	return acc, args.Error(1)
}

func (m *MockService) GetConfig() (Configuration, error) {
	args := m.Called()
	return args.Get(0).(Configuration), args.Error(1)
}

func (m *MockService) GetAccount(identifier []byte) (Account, error) {
	args := m.Called(identifier)
	acc, _ := args.Get(0).(Account)
	return acc, args.Error(1)
}

func (m *MockService) GetAccounts() ([]Account, error) {
	args := m.Called()
	v, _ := args.Get(0).([]Account)
	return v, args.Error(1)
}

func (m *MockService) CreateConfig(data Configuration) (Configuration, error) {
	args := m.Called(data)
	return args.Get(0).(Configuration), args.Error(0)
}

func (m *MockService) CreateAccount(data Account) (Account, error) {
	args := m.Called(data)
	acc, _ := args.Get(0).(Account)
	return acc, args.Error(1)
}

func (m *MockService) UpdateAccount(data Account) (Account, error) {
	args := m.Called(data)
	acc, _ := args.Get(0).(Account)
	return acc, args.Error(1)
}

func (m *MockService) DeleteAccount(identifier []byte) error {
	args := m.Called(identifier)
	return args.Error(0)
}

func (m *MockService) Sign(accountID, payload []byte) (*coredocumentpb.Signature, error) {
	args := m.Called(accountID, payload)
	sig, _ := args.Get(0).(*coredocumentpb.Signature)
	return sig, args.Error(1)
}

func (m *MockService) GenerateAccountAsync(cacc CentChainAccount) (did []byte, jobID []byte, err error) {
	args := m.Called(cacc)
	did, _ = args.Get(0).([]byte)
	jobID, _ = args.Get(1).([]byte)
	return did, jobID, args.Error(2)
}
