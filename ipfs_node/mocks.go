package ipfs_node

import (
	"context"
	"io"
	"testing"

	format "github.com/ipfs/go-ipld-format"
	"github.com/ipfs/interface-go-ipfs-core/path"

	iface "github.com/ipfs/interface-go-ipfs-core"
	"github.com/ipfs/interface-go-ipfs-core/options"
	"github.com/stretchr/testify/mock"
)

// ServiceMock is an autogenerated mock type for the Service type
type ServiceMock struct {
	mock.Mock
}

// GetBlock provides a mock function with given fields: ctx, blockPath
func (_m *ServiceMock) GetBlock(ctx context.Context, blockPath string) ([]byte, error) {
	ret := _m.Called(ctx, blockPath)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(context.Context, string) []byte); ok {
		r0 = rf(ctx, blockPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PutBlock provides a mock function with given fields: ctx, data, opts
func (_m *ServiceMock) PutBlock(ctx context.Context, data []byte, opts ...options.BlockPutOption) (iface.BlockStat, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 iface.BlockStat
	if rf, ok := ret.Get(0).(func(context.Context, []byte, ...options.BlockPutOption) iface.BlockStat); ok {
		r0 = rf(ctx, data, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.BlockStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []byte, ...options.BlockPutOption) error); ok {
		r1 = rf(ctx, data, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StatBlock provides a mock function with given fields: ctx, blockPath
func (_m *ServiceMock) StatBlock(ctx context.Context, blockPath string) (iface.BlockStat, error) {
	ret := _m.Called(ctx, blockPath)

	var r0 iface.BlockStat
	if rf, ok := ret.Get(0).(func(context.Context, string) iface.BlockStat); ok {
		r0 = rf(ctx, blockPath)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.BlockStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockPath)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewServiceMock creates a new instance of ServiceMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewServiceMock(t testing.TB) *ServiceMock {
	mock := &ServiceMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// CoreAPIMock is an autogenerated mock type for the CoreAPI type
type CoreAPIMock struct {
	mock.Mock
}

// Block provides a mock function with given fields:
func (_m *CoreAPIMock) Block() iface.BlockAPI {
	ret := _m.Called()

	var r0 iface.BlockAPI
	if rf, ok := ret.Get(0).(func() iface.BlockAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.BlockAPI)
		}
	}

	return r0
}

// Dag provides a mock function with given fields:
func (_m *CoreAPIMock) Dag() iface.APIDagService {
	ret := _m.Called()

	var r0 iface.APIDagService
	if rf, ok := ret.Get(0).(func() iface.APIDagService); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.APIDagService)
		}
	}

	return r0
}

// Dht provides a mock function with given fields:
func (_m *CoreAPIMock) Dht() iface.DhtAPI {
	ret := _m.Called()

	var r0 iface.DhtAPI
	if rf, ok := ret.Get(0).(func() iface.DhtAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.DhtAPI)
		}
	}

	return r0
}

// Key provides a mock function with given fields:
func (_m *CoreAPIMock) Key() iface.KeyAPI {
	ret := _m.Called()

	var r0 iface.KeyAPI
	if rf, ok := ret.Get(0).(func() iface.KeyAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.KeyAPI)
		}
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *CoreAPIMock) Name() iface.NameAPI {
	ret := _m.Called()

	var r0 iface.NameAPI
	if rf, ok := ret.Get(0).(func() iface.NameAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.NameAPI)
		}
	}

	return r0
}

// Object provides a mock function with given fields:
func (_m *CoreAPIMock) Object() iface.ObjectAPI {
	ret := _m.Called()

	var r0 iface.ObjectAPI
	if rf, ok := ret.Get(0).(func() iface.ObjectAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.ObjectAPI)
		}
	}

	return r0
}

// Pin provides a mock function with given fields:
func (_m *CoreAPIMock) Pin() iface.PinAPI {
	ret := _m.Called()

	var r0 iface.PinAPI
	if rf, ok := ret.Get(0).(func() iface.PinAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.PinAPI)
		}
	}

	return r0
}

// PubSub provides a mock function with given fields:
func (_m *CoreAPIMock) PubSub() iface.PubSubAPI {
	ret := _m.Called()

	var r0 iface.PubSubAPI
	if rf, ok := ret.Get(0).(func() iface.PubSubAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.PubSubAPI)
		}
	}

	return r0
}

// ResolveNode provides a mock function with given fields: _a0, _a1
func (_m *CoreAPIMock) ResolveNode(_a0 context.Context, _a1 path.Path) (format.Node, error) {
	ret := _m.Called(_a0, _a1)

	var r0 format.Node
	if rf, ok := ret.Get(0).(func(context.Context, path.Path) format.Node); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(format.Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, path.Path) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ResolvePath provides a mock function with given fields: _a0, _a1
func (_m *CoreAPIMock) ResolvePath(_a0 context.Context, _a1 path.Path) (path.Resolved, error) {
	ret := _m.Called(_a0, _a1)

	var r0 path.Resolved
	if rf, ok := ret.Get(0).(func(context.Context, path.Path) path.Resolved); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(path.Resolved)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, path.Path) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Swarm provides a mock function with given fields:
func (_m *CoreAPIMock) Swarm() iface.SwarmAPI {
	ret := _m.Called()

	var r0 iface.SwarmAPI
	if rf, ok := ret.Get(0).(func() iface.SwarmAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.SwarmAPI)
		}
	}

	return r0
}

// Unixfs provides a mock function with given fields:
func (_m *CoreAPIMock) Unixfs() iface.UnixfsAPI {
	ret := _m.Called()

	var r0 iface.UnixfsAPI
	if rf, ok := ret.Get(0).(func() iface.UnixfsAPI); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.UnixfsAPI)
		}
	}

	return r0
}

// WithOptions provides a mock function with given fields: _a0
func (_m *CoreAPIMock) WithOptions(_a0 ...options.ApiOption) (iface.CoreAPI, error) {
	_va := make([]interface{}, len(_a0))
	for _i := range _a0 {
		_va[_i] = _a0[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 iface.CoreAPI
	if rf, ok := ret.Get(0).(func(...options.ApiOption) iface.CoreAPI); ok {
		r0 = rf(_a0...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.CoreAPI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(...options.ApiOption) error); ok {
		r1 = rf(_a0...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewCoreAPIMock creates a new instance of CoreAPIMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewCoreAPIMock(t testing.TB) *CoreAPIMock {
	mock := &CoreAPIMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// BlockAPIMock is an autogenerated mock type for the BlockAPI type
type BlockAPIMock struct {
	mock.Mock
}

// Get provides a mock function with given fields: _a0, _a1
func (_m *BlockAPIMock) Get(_a0 context.Context, _a1 path.Path) (io.Reader, error) {
	ret := _m.Called(_a0, _a1)

	var r0 io.Reader
	if rf, ok := ret.Get(0).(func(context.Context, path.Path) io.Reader); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(io.Reader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, path.Path) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: _a0, _a1, _a2
func (_m *BlockAPIMock) Put(_a0 context.Context, _a1 io.Reader, _a2 ...options.BlockPutOption) (iface.BlockStat, error) {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 iface.BlockStat
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader, ...options.BlockPutOption) iface.BlockStat); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.BlockStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, io.Reader, ...options.BlockPutOption) error); ok {
		r1 = rf(_a0, _a1, _a2...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Rm provides a mock function with given fields: _a0, _a1, _a2
func (_m *BlockAPIMock) Rm(_a0 context.Context, _a1 path.Path, _a2 ...options.BlockRmOption) error {
	_va := make([]interface{}, len(_a2))
	for _i := range _a2 {
		_va[_i] = _a2[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _a0, _a1)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, path.Path, ...options.BlockRmOption) error); ok {
		r0 = rf(_a0, _a1, _a2...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Stat provides a mock function with given fields: _a0, _a1
func (_m *BlockAPIMock) Stat(_a0 context.Context, _a1 path.Path) (iface.BlockStat, error) {
	ret := _m.Called(_a0, _a1)

	var r0 iface.BlockStat
	if rf, ok := ret.Get(0).(func(context.Context, path.Path) iface.BlockStat); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(iface.BlockStat)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, path.Path) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewBlockAPIMock creates a new instance of BlockAPIMock. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewBlockAPIMock(t testing.TB) *BlockAPIMock {
	mock := &BlockAPIMock{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
